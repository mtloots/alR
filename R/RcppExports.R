# This file was generated by Rcpp::compileAttributes
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Objective function for KDE arc length matching.
#'
#' The arc lengths over specified intervals, in the domain of kernel density estimates, are matched.
#'
#' @param beta Vector of regression parameters.
#' @param gamma Design matrix.
#' @param aly A numerical vector of arc length segments to be matched to (same length as \code{beta}).
#' @param q1 A vector of points (not quantiles) specifying the lower limit of the arc length segments.
#' @param q2 A vector of points (not quantiles) specifying the upper limit of the arc length segments.
#'
#' @return Sum of squared differences between \code{gamma}*\code{beta} and \code{aly}.
#'
#' @export
alrKDE <- function(beta, gamma, aly, q1, q2) {
    .Call('alR_alrKDE', PACKAGE = 'alR', beta, gamma, aly, q1, q2)
}

#' Gaussian kernel density estimator.
#'
#' Estimate a density function using a kernel density estimator with a Gaussian kernel.
#'
#' The cumulative distribution function is calculated using the numerical integration C code implimented for R's integrate functions, i.e. using Rdqagi.  For this approximation, subdiv = 100 (100 subdivisions), and eps_abs = eps_rel = 1e-10, i.e. the absolute and relative errors respectively.
#'
#' The quantiles of the Gaussian kernel density estimator are calculated using Brent's method.  This method requires an interval in which a solution is saught.  The objective funcion for which a zero is saught is \code{\link{dkdeGauss}}-\code{x}, where \code{x} is the quantile saught.  The first interval in which a solution is searched for, corresponds to the range of \code{mu}, and is expanded in multiples thereof in consequtive steps.  The maximum number of iterations is set at 1000, and the accuracy saught between iterations, is set at 1e-10.
#'
#' @param x A data point, or quantile, at which the kernel density estimator should be evaluated.
#' @param mu A vector of data points on which the kernel density estimator is based.
#' @param h The kernel density estimator bandwidth.
#' @rdname kdeGauss
#' @return dkdeGauss: The estimated value of the density function at the point x.
#' @examples
#' library(alR)
#' x <- rnorm(100)
#' h_x <- Silverman(x)
#' dkdeGauss(0, x, h_x)
#' @export
dkdeGauss <- function(x, mu, h) {
    .Call('alR_dkdeGauss', PACKAGE = 'alR', x, mu, h)
}

#' @rdname kdeGauss
#' @examples
#' pkdeGauss(0, x, h_x)
#' @return pkdeGauss: A list with the following components:
#' \itemize{
#' \item value: The estimated value of the cumulative distribution function at the point \code{x}.
#' \item abs.err: The absolute error between iterations.
#' subdivisions: Number of subdivisions used in the numerical approximation.
#' \item neval: Number of function evaluations used by the numerical approximation.
#' }
#' @export
pkdeGauss <- function(x, mu, h) {
    .Call('alR_pkdeGauss', PACKAGE = 'alR', x, mu, h)
}

#' @rdname kdeGauss
#' @examples
#' qkdeGauss(0.5, x, h_x)
#' @return qkdeGauss: A list with the following components:
#' \itemize{
#' \item result: The \code{x}th quantile of the Gaussian kernel density estimator.
#' \item value: The value of the cumulative distribution function of the Gaussian kernel density estimator at the \code{x}th quantile.
#' \item obj.fun: The value of the objective function resulting from Brent's method; should be less than 1e-10.
#' \item iterations: Number of iterations for Brent's method in order to achieve the desired accuracy.
#' \item steps: Number of range expansions of the search boundaries for Brent's method.
#' }
#' @export
qkdeGauss <- function(x, mu, h) {
    .Call('alR_qkdeGauss', PACKAGE = 'alR', x, mu, h)
}

#' Arc length of Gaussian KDE.
#'
#' Calculate the arc length for a univariate Gaussian kernel density estimator over a specified interval.
#'
#' The arc length of a univariate Gaussian kernel density estimator is approximated using the numerical integration C code implimented for R's integrate functions, i.e. using Rdqags.  For this approximation, subdiv = 100 (100 subdivisions), and eps_abs = eps_rel = 1e-10, i.e. the absolute and relative errors respectively.
#'
#' @param mu A vector of data points on which the kernel density estimator is based.
#' @param h The kernel density estimator bandwidth.
#' @param q1 The point (or vector for \code{kdeGaussInt2}) specifying the lower limit of the arc length integral.
#' @param q2 The point (or vector for \code{kdeGaussInt2}) specifying the upper limit of the arc length integral.
#' @param quantile Logical, TRUE/FALSE, whether \code{q1} and \code{q2} are quantiles, or actual points in the domain.
#'
#' @return kdeGaussInt: A list with the following components:
#' \itemize{
#' \item value: The resultant arc length.
#' \item abs.err: The absolute error between iterations.
#' subdivisions: Number of subdivisions used in the numerical approximation.
#' \item neval: Number of function evaluations used by the numerical approximation.
#' }
#'
#' @examples
#' library(alR)
#' mu <- rnorm(100)
#' h <- Silverman(mu)
#' kdeGaussInt(mu, h, 0.025, 0.975, TRUE)
#' kdeGaussInt(mu, h, -1.96, 1.96, FALSE)
#'
#' @export
kdeGaussInt <- function(mu, h, q1, q2, quantile) {
    .Call('alR_kdeGaussInt', PACKAGE = 'alR', mu, h, q1, q2, quantile)
}

#' @rdname kdeGaussInt
#' @return kdeGaussInt2: A vector having length equal to that of the vector of lower quantile bounds, containing the arc lengths requested for a Gaussian kernel density estimator.
#'
#' @examples
#' kdeGaussInt2(mu, h, c(0.025, 0.5), c(0.5, 0.975), TRUE)
#' kdeGaussInt2(mu, h, c(-1.96, 0), c(0, 1.96), FALSE)
#'
#' @export
kdeGaussInt2 <- function(mu, h, q1, q2, quantile) {
    .Call('alR_kdeGaussInt2', PACKAGE = 'alR', mu, h, q1, q2, quantile)
}

#' Objective function for KDE moment matching.
#'
#' The moments of kernel density estimates are matched.
#'
#' @param beta Vector of regression parameters.
#' @param gamma Design matrix.
#' @param momy A numerical vector of moments to be matched to (same length as \code{beta}).
#' @param kdeGaussMom A R function object to be passed that calculates exact moments.
#'
#' @return Sum of squared differences between \code{gamma}*\code{beta} and \code{momy}.
#'
#' @export
momKDE <- function(beta, gamma, momy, kdeGaussMom) {
    .Call('alR_momKDE', PACKAGE = 'alR', beta, gamma, momy, kdeGaussMom)
}

#' Silverman's rule of thumb.
#'
#' Calculate the bandwidth estimator using Silverman's rule of thumb.
#'
#' @param x A vector of data points.
#'
#' @return Bandwidth estimator based on Silverman's rule of thumb.
#'
#' @examples
#' set.seed(1)
#' x <- rnorm(100)
#' Silverman(x)
#'
#' @export
Silverman <- function(x) {
    .Call('alR_Silverman', PACKAGE = 'alR', x)
}

